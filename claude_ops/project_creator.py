"""
Unified Project Creator
Provides consistent project creation functionality for both CLI and Telegram interfaces
"""

import os
import subprocess
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime

logger = logging.getLogger(__name__)


class ProjectCreator:
    """Unified project creation with Git initialization and complete setup"""
    
    def __init__(self, project_name: str, project_path: Optional[str] = None):
        self.project_name = project_name
        self.session_name = f"claude_{project_name}"
        
        # Determine target directory
        if project_path:
            self.project_dir = Path(project_path).resolve()
        else:
            self.project_dir = Path.home() / "projects" / project_name
        
        self.results = {
            "project_name": project_name,
            "project_path": str(self.project_dir),
            "session_name": self.session_name,
            "git_initialized": False,
            "session_created": False,
            "status": "pending"
        }
    
    def create_project(self, initialize_git: bool = True, install_dev_kit: bool = True) -> Dict[str, Any]:
        """Create complete project with all features"""
        try:
            logger.info(f"üöÄ Creating project: {self.project_name}")
            
            # Step 1: Create directory
            if not self._create_directory():
                return self._error_result("Directory creation failed")
            
            # Step 2: Initialize Git repository (if requested)
            if initialize_git:
                if not self._initialize_git():
                    return self._error_result("Git initialization failed")
            
            # Step 3: Install development kit (if requested)
            if install_dev_kit:
                if not self._install_dev_kit():
                    logger.warning("Dev kit installation failed, continuing...")
            
            # Step 4: Create tmux session
            if not self._create_tmux_session():
                return self._error_result("Tmux session creation failed")
            
            # Success
            self.results.update({
                "status": "success",
                "message": f"‚úÖ Project '{self.project_name}' created successfully!",
                "created_at": datetime.now().isoformat()
            })
            
            logger.info(f"‚úÖ Project creation completed: {self.project_name}")
            return self.results
            
        except Exception as e:
            logger.error(f"‚ùå Project creation failed: {e}")
            return self._error_result(f"Unexpected error: {str(e)}")
    
    def _create_directory(self) -> bool:
        """Create project directory"""
        try:
            self.project_dir.mkdir(parents=True, exist_ok=True)
            logger.info(f"üìÅ Created directory: {self.project_dir}")
            return True
        except Exception as e:
            logger.error(f"Directory creation error: {e}")
            return False
    
    def _initialize_git(self) -> bool:
        """Initialize Git repository with .gitignore and initial commit"""
        try:
            # Check if already a git repository
            if (self.project_dir / ".git").exists():
                logger.info("üì¶ Git repository already exists")
                self.results["git_initialized"] = True
                return True
            
            # Change to project directory
            original_cwd = os.getcwd()
            os.chdir(self.project_dir)
            
            try:
                # Initialize git
                result = subprocess.run(
                    ["git", "init"], 
                    capture_output=True, 
                    text=True, 
                    timeout=30
                )
                if result.returncode != 0:
                    logger.error(f"Git init failed: {result.stderr}")
                    return False
                
                # Create comprehensive .gitignore
                gitignore_content = self._get_gitignore_template()
                gitignore_path = self.project_dir / ".gitignore"
                gitignore_path.write_text(gitignore_content, encoding='utf-8')
                
                # Add and commit
                subprocess.run(["git", "add", ".gitignore"], check=True, timeout=10)
                
                commit_message = f"""üéâ Initial commit - Project: {self.project_name}

Generated by Claude-Ops ProjectCreator
Directory: {self.project_dir}
Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"""
                
                subprocess.run(
                    ["git", "commit", "-m", commit_message], 
                    check=True, 
                    timeout=10
                )
                
                logger.info("üì¶ Git repository initialized with .gitignore and initial commit")
                self.results["git_initialized"] = True
                return True
                
            finally:
                os.chdir(original_cwd)
                
        except subprocess.TimeoutExpired:
            logger.error("Git operations timed out")
            return False
        except subprocess.CalledProcessError as e:
            logger.error(f"Git command failed: {e}")
            return False
        except Exception as e:
            logger.error(f"Git initialization error: {e}")
            return False
    
    def _get_gitignore_template(self) -> str:
        """Get comprehensive .gitignore template"""
        return """# Python
__pycache__/
*.py[cod]
*$py.class
.venv/
venv/
.env
*.egg-info/
dist/
build/
.pytest_cache/
.ruff_cache/

# Node
node_modules/
dist/
build/
.cache/
.parcel-cache/
coverage/
*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Claude
.claude/
CLAUDE.md

# Environment
.env
.env.local

# Jupyter
.ipynb_checkpoints/
*.ipynb_checkpoints

# ML/AI
models/
checkpoints/
*.h5
*.pkl
*.pth
wandb/
mlruns/

# Database
*.db
*.sqlite
*.sqlite3

# Temporary files
*.tmp
*.temp
.tmp/
.temp/
"""
    
    def _install_dev_kit(self) -> bool:
        """Install development kit with claude-dev-kit remote installation"""
        try:
            logger.info("üõ†Ô∏è Starting claude-dev-kit installation...")
            
            # Try remote claude-dev-kit installation first
            if self._install_remote_claude_dev_kit():
                logger.info("‚úÖ Remote claude-dev-kit installation successful")
                return True
            else:
                logger.warning("‚ö†Ô∏è Remote installation failed, falling back to local setup")
                return self._install_local_fallback()
                
        except Exception as e:
            logger.error(f"Dev kit installation error: {e}")
            logger.info("üîÑ Falling back to local setup")
            return self._install_local_fallback()
    
    def _install_remote_claude_dev_kit(self) -> bool:
        """Install claude-dev-kit from remote repository"""
        try:
            original_cwd = os.getcwd()
            os.chdir(self.project_dir)
            
            try:
                install_command = (
                    f"curl -sSL https://raw.githubusercontent.com/kyuwon-shim-ARL/claude-dev-kit/main/install.sh | "
                    f"bash -s {self.project_name} 'Claude-managed project with dev-ops automation'"
                )
                
                logger.info(f"Executing remote installation: {install_command[:80]}...")
                result = subprocess.run(
                    install_command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                if result.returncode == 0:
                    logger.info("üöÄ Claude-dev-kit remote installation completed successfully")
                    return True
                else:
                    logger.warning(f"Remote installation failed: {result.stderr[:200]}")
                    return False
                    
            finally:
                os.chdir(original_cwd)
                
        except subprocess.TimeoutExpired:
            logger.warning("Remote installation timed out after 30 seconds")
            return False
        except Exception as e:
            logger.error(f"Remote installation error: {e}")
            return False
    
    def _install_local_fallback(self) -> bool:
        """Fallback to local basic project structure"""
        try:
            # Create basic project structure
            (self.project_dir / "src").mkdir(exist_ok=True)
            (self.project_dir / "tests").mkdir(exist_ok=True)
            (self.project_dir / "docs").mkdir(exist_ok=True)
            
            # Create basic README
            readme_content = f"""# {self.project_name}

Created with Claude-Ops ProjectCreator

## Getting Started

This project was created on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} using Claude-Ops.

## Project Structure

- `src/` - Source code
- `tests/` - Test files  
- `docs/` - Documentation

## Development

Start working in your Claude session:
```bash
tmux attach -t {self.session_name}
```

## Claude Integration

This project is set up for Claude Code development with:
- Git repository initialized
- Comprehensive .gitignore
- Project structure ready
- tmux session configured

## Note

This project uses a basic template. For enhanced features, ensure network connectivity 
during project creation to install the full claude-dev-kit.
"""
            
            readme_path = self.project_dir / "README.md"
            readme_path.write_text(readme_content, encoding='utf-8')
            
            logger.info("üìù Local fallback development kit installed")
            return True
            
        except Exception as e:
            logger.error(f"Local fallback installation error: {e}")
            return False
    
    def _create_tmux_session(self) -> bool:
        """Create tmux session for the project"""
        try:
            # Check if session already exists
            check_result = subprocess.run(
                ["tmux", "has-session", "-t", self.session_name],
                capture_output=True,
                timeout=10
            )
            
            if check_result.returncode == 0:
                logger.info(f"üéØ Session '{self.session_name}' already exists")
                self.results["session_created"] = True
                return True
            
            # Create new session
            subprocess.run([
                "tmux", "new-session", "-d", "-s", self.session_name,
                "-c", str(self.project_dir)
            ], check=True, timeout=10)
            
            # Start claude in the session
            subprocess.run([
                "tmux", "send-keys", "-t", self.session_name, "claude", "Enter"
            ], check=True, timeout=5)
            
            logger.info(f"üéØ Created tmux session: {self.session_name}")
            self.results["session_created"] = True
            return True
            
        except subprocess.TimeoutExpired:
            logger.error("Tmux operations timed out")
            return False
        except subprocess.CalledProcessError as e:
            logger.error(f"Tmux command failed: {e}")
            return False
        except Exception as e:
            logger.error(f"Tmux session creation error: {e}")
            return False
    
    def _error_result(self, error_message: str) -> Dict[str, Any]:
        """Create error result"""
        self.results.update({
            "status": "error",
            "error": error_message,
            "failed_at": datetime.now().isoformat()
        })
        return self.results
    
    @classmethod
    def create_project_simple(
        cls, 
        project_name: str, 
        project_path: Optional[str] = None,
        initialize_git: bool = True,
        install_dev_kit: bool = True
    ) -> Dict[str, Any]:
        """Simple class method for creating projects"""
        creator = cls(project_name, project_path)
        return creator.create_project(initialize_git, install_dev_kit)


def main():
    """CLI interface for testing ProjectCreator"""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python -m claude_ops.project_creator <project_name> [project_path]")
        return
    
    project_name = sys.argv[1]
    project_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    result = ProjectCreator.create_project_simple(project_name, project_path)
    
    if result["status"] == "success":
        print(f"‚úÖ {result['message']}")
        print(f"üìÅ Path: {result['project_path']}")
        print(f"üéØ Session: {result['session_name']}")
        if result.get('git_initialized'):
            print("üì¶ Git repository initialized")
    else:
        print(f"‚ùå Error: {result['error']}")


if __name__ == "__main__":
    main()